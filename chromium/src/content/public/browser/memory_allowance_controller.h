// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
//
// Copyright (C) 2013 Opera Software ASA.  All rights reserved.
//
// This file is an original work developed by Opera Software ASA

#ifndef CONTENT_PUBLIC_BROWSER_MEMORY_ALLOWANCE_CONTROLLER_H_
#define CONTENT_PUBLIC_BROWSER_MEMORY_ALLOWANCE_CONTROLLER_H_

#include "base/basictypes.h"
#include "content/common/content_export.h"
#include "content/public/browser/browser_message_filter.h"

// A MemoryAllowanceController is used to maintain a browser wide
// limit on system memory. It is achived by working in concert with
// the MemoryAllowanceAgents of the child processes. The limit is seen
// as a global, browser wide, "memory allowance". Each process borrows
// from this global allowance to maintain a local memory limit of
// their own. A process is given an inital startup allowance when
// launched. At that point the controller either hands out allowance
// to the process or denies launch by giving it no allowance. Once
// started, the process instantiates a MemoryAllowanceAgent that
// counts memory usage and communicates with the controller to ensure
// that the process has enough allowance to match its memory
// use. Similarly, the controller must ensure that the global
// allowance is not depleted. Doing so, it might deny processes to
// increase their memory allowance, or command processes to give up
// memory allowance.

namespace switches {
// Set when a child process is launched to communicate its startup allowance.
extern const char kMemoryAllowance[];
}

namespace content {

class CONTENT_EXPORT MemoryAllowanceController {
 public:
  // Returns the singleton instance.
  static MemoryAllowanceController* GetInstance();

  // Overrides the default instance. Should be setup before
  // GetInstance() is called for the first time.
  // NOTE: Calling SetInstance() transfers ownership of the
  // instance. The caller must not delete the instance.
  static void SetInstance(MemoryAllowanceController* instance);

  MemoryAllowanceController();

  virtual bool Enabled() = 0;

  // Create a message filter for the child process id.
  // id is the unique process id generated by
  // ChildProcessHostImpl::GenerateChildProcessUniqueId().
  virtual BrowserMessageFilter* CreateMessageFilter(int id) = 0;

  // Calculates and reserves startup allowance for the given process.
  // A zero return value fails the process launch.
  virtual int64 InitializeProcessAllowance(int id) = 0;

  // Called to notify the controller that the IO-thread has been started.
  virtual void OnIOThreadUp(
      const scoped_refptr<base::MessageLoopProxy>& message_loop_proxy) = 0;

  // Called to notify the controller that the IO-thread is shutting down.
  virtual void OnIOThreadDown() = 0;

 protected:
  // NOTE: Once created, the memory allowance controller is never deleted.
  // So, don't write code that depends on the destructor getting called.
  // Consider adding cleanup code in OnIOThreadDown() if needed.
  virtual ~MemoryAllowanceController();

 private:
  static MemoryAllowanceController* instance_;
  DISALLOW_COPY_AND_ASSIGN(MemoryAllowanceController);
};


}  // namespace content

#endif  // CONTENT_PUBLIC_BROWSER_MEMORY_ALLOWANCE_CONTROLLER_H_
